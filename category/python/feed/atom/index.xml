<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Kebot</title>
  <subtitle type="text">Keith is Robot</subtitle>

  <updated>2011-11-27T12:28:56Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://kebot.me/" />
  <id>http://kebot.me//feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://kebot.me//feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://kebot.me/</uri>
    </author>
    <title type="html"><![CDATA[文件保存时自动刷新浏览器 F5 For Mac and VIM]]></title>
    <link rel="alternate" type="text/html" href="http://kebot.me/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/" />
    <id>http://kebot.me/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/</id>
    <updated>2011-09-15T19:08:47Z</updated>
    <published>2011-09-15T19:08:47Z</published>
    <category scheme="http://kebot.me/" term="Python" />
    <category scheme="http://kebot.me/" term="Mac" />
    <summary type="html"><![CDATA[文件保存时自动刷新浏览器 F5 For Mac and VIM]]></summary>
    <content type="html" xml:base="http://kebot.me/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/"><![CDATA[
最近发现 [F5](http://www.getf5.com/)这个插件很火,于是去看了下简介,其实就是检测一个文件夹里面的文件改动,然后自动刷新浏览器,不过看上去只支持windows. 因为我一直在用 VIM , 于是就写了几行代码实现了 "保存文件自动刷新这个功能" 不过,首先,必须确保你的机器是Mac和GoogleChrome浏览器 为了让代码更加Python一点,于是我用了appscript这个python库,所以要先运行下这行代码 
<pre lang="bash"> 
easy_install appscript 
# 或者 
pip install appscript 
</pre>

然后将下面这些话加入你的 .vimrc 
<pre lang="python"> 
autocmd BufWritePost *.coffee,*.css,*.html :call Refresh_Chrome()

function! Refresh_Chrome()
python << EOF
import appscript
appscript.app("Google Chrome").windows[0].active_tab.reload()
EOF
endfunction

</pre>
======================================================================== 现在已经够用了,以后可以考虑写一个python脚本来监测文件夹的改动并刷新浏览器]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://kebot.me/</uri>
    </author>
    <title type="html"><![CDATA[Use Google Fusion Tables with Python]]></title>
    <link rel="alternate" type="text/html" href="http://kebot.me/2010/10/google-fusion-tables-with-python/" />
    <id>http://kebot.me/2010/10/google-fusion-tables-with-python/</id>
    <updated>2010-10-16T23:33:40Z</updated>
    <published>2010-10-16T23:33:40Z</published>
    <category scheme="http://kebot.me/" term="Python" />
    <category scheme="http://kebot.me/" term="Kohana_Framework" />
    <summary type="html"><![CDATA[Use Google Fusion Tables with Python]]></summary>
    <content type="html" xml:base="http://kebot.me/2010/10/google-fusion-tables-with-python/"><![CDATA[
用法:
创建数据库
<pre lang="python">import sys
import os
from ftclient import *
TABLE_COLUMN =('word','STRING') , ('data','DATETIME') , ('sentence','STRING') ,('url' , 'STRING')
TABLE_NAME = "tableKebot"
def main():
	email = 'kebot'
	password = 'http://kebot.me/'
	token = GetAuthToken(email,password)
	fb = FTClient(token)

	fb.createTable(TABLE_NAME,TABLE_COLUMN)

	pass

if __name__ == "__main__":
	main()
</pre>

上面用到的FTClient库:
<pre lang="python">#!/usr/bin/python
#
# Copyright 2010 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Google Fusion Tables client library."""

import cookielib
import csv
import getpass
import os
import time
import urllib
import urllib2

class FTClient(object):
    """Fusion Table SQL API wrapper."""

    def __init__(self, auth_token):
        self.ft_host = 'http://tables.googlelabs.com'
        self.api_path = '/api/query'
        self.auth_token = auth_token

    def runGetQuery(self, query):
        """Issue a GET query to the Fusion Tables API and return the result."""
        encoded_query_params = urllib.urlencode({'sql': query})
        path = self.ft_host + self.api_path + '?' + encoded_query_params
        data = ''
        headers = {
            'Authorization': 'GoogleLogin auth=' + self.auth_token,
        }
        serv_req = urllib2.Request(path, data, headers)
        serv_resp = urllib2.urlopen(serv_req)
        serv_resp_body = serv_resp.read()

        return serv_resp_body

    def runPostQuery(self, query):
        """Issue a POST query to the Fusion Tables API and return the result."""
        path = self.ft_host + self.api_path
        data = urllib.urlencode({'sql': query})
        headers = {
            'Authorization': 'GoogleLogin auth=' + self.auth_token,
            'Content-Type': 'application/x-www-form-urlencoded',
        }

        # Debug code -- uncomment if you need to see what's on the wire
        # h = urllib2.HTTPHandler(debuglevel=1)
        # opener = urllib2.build_opener(h)
        # urllib2.install_opener(opener)

        serv_req = urllib2.Request(path, data, headers)
        serv_resp = urllib2.urlopen(serv_req)
        serv_resp_body = serv_resp.read()

        return serv_resp_body

    def createTable(self, table_name, column_names_and_types):
        """Creates a table in Fusion Tables and returns the table ID."""
        column_defs = ', '.join(["'%s':%s" % c for c in column_names_and_types])
        query = 'CREATE TABLE %s (%s)' % (table_name, column_defs)
        response = self.runPostQuery(query)
        # Grab the table id from the response
        table_id = response.split('\n')[1]

        return table_id

    def createTableFromCSV(self, filename, table_name=None, type_mappings=None):
        """Create a table in Fusion Tables from a CSV file with a header."""
        type_mappings = type_mappings or {}

        fin = open(filename)
        csv_reader = csv.reader(fin)
        cols = csv_reader.next()
        columns_and_types = [(c, type_mappings.get(c, 'STRING')) for c in cols]

        table_id = self.createTable(table_name or filename, columns_and_types)

        return table_id

    def uploadCSV(self, table_id, filename, bulk=True):
        """Upload a CSV to an existing table."""
        fin = open(filename)
        csv_reader = csv.reader(fin)
        header_parts = csv_reader.next()
        col_keys = ','.join(["'%s'" % s for s in header_parts])
        start_time = time.time()

        if bulk:
            # Upload multiple rows at once
            max_per_batch = 500
            num_in_batch = max_per_batch
            while num_in_batch == max_per_batch:
                num_in_batch = 0
                queries = []
                for line_parts in csv_reader:
                    line_parts = [s.replace("'", "''") for s in line_parts]
                    fixed_line = ','.join(["'%s'" % s for s in line_parts])
                    query = 'INSERT INTO %s (%s) VALUES (%s)' % (
                        table_id, col_keys, fixed_line)
                    queries.append(query)
                    num_in_batch += 1
                    if num_in_batch == max_per_batch:
                        break

                try:
                    full_query = ';'.join(queries)
                    self.runPostQuery(full_query)
                except urllib2.HTTPError:
                    # Had an error with all the INSERTS; do them one at a time
                    print 'Exception hit, subdividing:'
                    for query in queries:
                        try:
                            self.runPostQuery(query)
                        except urllib2.HTTPError, e2:
                            print 'Error at query %s:' % query
                            print e2

                    print 'Appended %d rows' % num_in_batch

        else:
            # Upload one line at a time
            for line_parts in csv_reader:
                line_parts = [s.strip("'") for s in line_parts]
                fixed_line = ','.join(["'%s'" % s for s in line_parts])
                query = 'INSERT INTO %s (%s) VALUES (%s)' % (
                    table_id, col_keys, fixed_line)
                self.runPostQuery(query)
        end_time = time.time()
        print 'Time for upload to %s: %f  (bulk: %s)' % (
            table_id, end_time - start_time, str(bulk))

#
# ClientLogin stuff
#
# This should probably be replaced with the real GData API at some point,
# but now for convenience these functions are included here
#

def GoogleClientLogin(username, pw):
    """Log in to google accounts and return the authorization token."""
    # we use a cookie to authenticate with Google App Engine
    #  by registering a cookie handler here, this will automatically store the
    #  cookie returned when we use urllib2
    cookiejar = cookielib.LWPCookieJar()
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookiejar))
    urllib2.install_opener(opener)

    #
    # get an AuthToken from Google accounts
    #
    auth_uri = 'https://www.google.com/accounts/ClientLogin'
    authreq_data = urllib.urlencode({
        'Email': username,
        'Passwd': pw,
        'service': 'fusiontables',
        'accountType': 'HOSTED_OR_GOOGLE'})
    auth_req = urllib2.Request(auth_uri, data=authreq_data)
    auth_resp = urllib2.urlopen(auth_req)
    auth_resp_body = auth_resp.read()
    # auth response includes several fields - we're interested in
    #  the bit after Auth=
    auth_resp_dict = dict(
        x.split('=') for x in auth_resp_body.split('\n') if x)
    authtoken = auth_resp_dict['Auth']
    return authtoken

def GetAuthToken(users_email_address=None, users_password=None):
    """Tries to log in and returns auth token. Saves token for future use.

    Will prompt for password if not present.
    """
    # Check to see if it's on disk
    if (os.path.exists('.ftclient_authtoken')):
        token = open('.ftclient_authtoken').read().strip()
    else:
        if not users_email_address:
            users_email_address = raw_input('Email address:')
        if not users_password:
            users_password = getpass.getpass(
                'Password for %s: ' % users_email_address)

        token = GoogleClientLogin(users_email_address, users_password)

        fout = open('.ftclient_authtoken', 'w')
        fout.write(token)
        fout.close()

    return token

if __name__ == '__main__':
	pass</pre>
</pre>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://kebot.me/</uri>
    </author>
    <title type="html"><![CDATA[Sync Your ITunes]]></title>
    <link rel="alternate" type="text/html" href="http://kebot.me/2010/09/syncyouritunes/" />
    <id>http://kebot.me/2010/09/syncyouritunes/</id>
    <updated>2010-09-26T07:45:50Z</updated>
    <published>2010-09-26T07:45:50Z</published>
    <category scheme="http://kebot.me/" term="Python" />
    <category scheme="http://kebot.me/" term="Project" />
    <category scheme="http://kebot.me/" term="Mac" />
    <summary type="html"><![CDATA[Sync Your ITunes]]></summary>
    <content type="html" xml:base="http://kebot.me/2010/09/syncyouritunes/"><![CDATA[
<a href="http://kebot.me/wp-content/uploads/2010/09/icon-grey.jpg"><img class="alignnone size-medium wp-image-5" title="icon-grey" src="http://kebot.me/wp-content/uploads/2010/09/icon-grey-281x300.jpg" alt="" width="281" height="300" /></a>

Project Home:

http://code.google.com/p/syncyouritunes/]]></content>
  </entry>
</feed>
