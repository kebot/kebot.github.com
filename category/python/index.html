


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Kebot</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/feed/atom" />
<link rel='stylesheet' href='/css/pygments_murphy.css' type='text/css' />


  </head>
  <body>
    <div id="content">
      
  <h1><a href="/">Kebot</a></h1>
<p>This is a simple blog build with Blogofile.</p>
<p>It's completely unthemed and is written as minimally as possible, while still
retaining most of the blog features.</p>
<p>Make sure you read the <a href="http://www.blogofile.com/documentation">online
documentation</a>.</p>
<p>If you're looking for a more fleshed-out site try running 'blogofile init
blogofile.com', but you'll need <a href="http://www.git-scm.org">git</a> installed first.</p>
<p>This is a header that goes on every page.</p>
<hr/>


      <div id="main_block">
        <div id="prose_block">
          
  
<div class="blog_post">
  <a name="文件保存时自动刷新浏览器-f5-for-mac-and-vim"></a>
  <h2 class="blog_post_title"><a href="/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/" rel="bookmark" title="Permanent Link to 文件保存时自动刷新浏览器 F5 For Mac and VIM">文件保存时自动刷新浏览器 F5 For Mac and VIM</a></h2>
  <small>September 15, 2011 at 07:08 PM | categories: 

<a href='/category/python'>Python</a>, <a href='/category/mac'>Mac</a>
 | <a href="http://kebot.me/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  
最近发现 [F5](http://www.getf5.com/)这个插件很火,于是去看了下简介,其实就是检测一个文件夹里面的文件改动,然后自动刷新浏览器,不过看上去只支持windows. 因为我一直在用 VIM , 于是就写了几行代码实现了 "保存文件自动刷新这个功能" 不过,首先,必须确保你的机器是Mac和GoogleChrome浏览器 为了让代码更加Python一点,于是我用了appscript这个python库,所以要先运行下这行代码 
<pre lang="bash"> 
easy_install appscript 
# 或者 
pip install appscript 
</pre>

然后将下面这些话加入你的 .vimrc 
<pre lang="python"> 
autocmd BufWritePost *.coffee,*.css,*.html :call Refresh_Chrome()

function! Refresh_Chrome()
python << EOF
import appscript
appscript.app("Google Chrome").windows[0].active_tab.reload()
EOF
endfunction

</pre>
======================================================================== 现在已经够用了,以后可以考虑写一个python脚本来监测文件夹的改动并刷新浏览器

  </div>
</div>



  <div class="after_post"><a href="http://kebot.me/2011/09/%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e6%97%b6%e8%87%aa%e5%8a%a8%e5%88%b7%e6%96%b0%e6%b5%8f%e8%a7%88%e5%99%a8-f5-for-mac-and-vim/#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="use-google-fusion-tables-with-python"></a>
  <h2 class="blog_post_title"><a href="/2010/10/google-fusion-tables-with-python/" rel="bookmark" title="Permanent Link to Use Google Fusion Tables with Python">Use Google Fusion Tables with Python</a></h2>
  <small>October 16, 2010 at 11:33 PM | categories: 

<a href='/category/python'>Python</a>, <a href='/category/kohana_framework'>Kohana_Framework</a>
 | <a href="http://kebot.me/2010/10/google-fusion-tables-with-python/#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  
用法:
创建数据库
<pre lang="python">import sys
import os
from ftclient import *
TABLE_COLUMN =('word','STRING') , ('data','DATETIME') , ('sentence','STRING') ,('url' , 'STRING')
TABLE_NAME = "tableKebot"
def main():
	email = 'kebot'
	password = 'http://kebot.me/'
	token = GetAuthToken(email,password)
	fb = FTClient(token)

	fb.createTable(TABLE_NAME,TABLE_COLUMN)

	pass

if __name__ == "__main__":
	main()
</pre>

上面用到的FTClient库:
<pre lang="python">#!/usr/bin/python
#
# Copyright 2010 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Google Fusion Tables client library."""

import cookielib
import csv
import getpass
import os
import time
import urllib
import urllib2

class FTClient(object):
    """Fusion Table SQL API wrapper."""

    def __init__(self, auth_token):
        self.ft_host = 'http://tables.googlelabs.com'
        self.api_path = '/api/query'
        self.auth_token = auth_token

    def runGetQuery(self, query):
        """Issue a GET query to the Fusion Tables API and return the result."""
        encoded_query_params = urllib.urlencode({'sql': query})
        path = self.ft_host + self.api_path + '?' + encoded_query_params
        data = ''
        headers = {
            'Authorization': 'GoogleLogin auth=' + self.auth_token,
        }
        serv_req = urllib2.Request(path, data, headers)
        serv_resp = urllib2.urlopen(serv_req)
        serv_resp_body = serv_resp.read()

        return serv_resp_body

    def runPostQuery(self, query):
        """Issue a POST query to the Fusion Tables API and return the result."""
        path = self.ft_host + self.api_path
        data = urllib.urlencode({'sql': query})
        headers = {
            'Authorization': 'GoogleLogin auth=' + self.auth_token,
            'Content-Type': 'application/x-www-form-urlencoded',
        }

        # Debug code -- uncomment if you need to see what's on the wire
        # h = urllib2.HTTPHandler(debuglevel=1)
        # opener = urllib2.build_opener(h)
        # urllib2.install_opener(opener)

        serv_req = urllib2.Request(path, data, headers)
        serv_resp = urllib2.urlopen(serv_req)
        serv_resp_body = serv_resp.read()

        return serv_resp_body

    def createTable(self, table_name, column_names_and_types):
        """Creates a table in Fusion Tables and returns the table ID."""
        column_defs = ', '.join(["'%s':%s" % c for c in column_names_and_types])
        query = 'CREATE TABLE %s (%s)' % (table_name, column_defs)
        response = self.runPostQuery(query)
        # Grab the table id from the response
        table_id = response.split('\n')[1]

        return table_id

    def createTableFromCSV(self, filename, table_name=None, type_mappings=None):
        """Create a table in Fusion Tables from a CSV file with a header."""
        type_mappings = type_mappings or {}

        fin = open(filename)
        csv_reader = csv.reader(fin)
        cols = csv_reader.next()
        columns_and_types = [(c, type_mappings.get(c, 'STRING')) for c in cols]

        table_id = self.createTable(table_name or filename, columns_and_types)

        return table_id

    def uploadCSV(self, table_id, filename, bulk=True):
        """Upload a CSV to an existing table."""
        fin = open(filename)
        csv_reader = csv.reader(fin)
        header_parts = csv_reader.next()
        col_keys = ','.join(["'%s'" % s for s in header_parts])
        start_time = time.time()

        if bulk:
            # Upload multiple rows at once
            max_per_batch = 500
            num_in_batch = max_per_batch
            while num_in_batch == max_per_batch:
                num_in_batch = 0
                queries = []
                for line_parts in csv_reader:
                    line_parts = [s.replace("'", "''") for s in line_parts]
                    fixed_line = ','.join(["'%s'" % s for s in line_parts])
                    query = 'INSERT INTO %s (%s) VALUES (%s)' % (
                        table_id, col_keys, fixed_line)
                    queries.append(query)
                    num_in_batch += 1
                    if num_in_batch == max_per_batch:
                        break

                try:
                    full_query = ';'.join(queries)
                    self.runPostQuery(full_query)
                except urllib2.HTTPError:
                    # Had an error with all the INSERTS; do them one at a time
                    print 'Exception hit, subdividing:'
                    for query in queries:
                        try:
                            self.runPostQuery(query)
                        except urllib2.HTTPError, e2:
                            print 'Error at query %s:' % query
                            print e2

                    print 'Appended %d rows' % num_in_batch

        else:
            # Upload one line at a time
            for line_parts in csv_reader:
                line_parts = [s.strip("'") for s in line_parts]
                fixed_line = ','.join(["'%s'" % s for s in line_parts])
                query = 'INSERT INTO %s (%s) VALUES (%s)' % (
                    table_id, col_keys, fixed_line)
                self.runPostQuery(query)
        end_time = time.time()
        print 'Time for upload to %s: %f  (bulk: %s)' % (
            table_id, end_time - start_time, str(bulk))

#
# ClientLogin stuff
#
# This should probably be replaced with the real GData API at some point,
# but now for convenience these functions are included here
#

def GoogleClientLogin(username, pw):
    """Log in to google accounts and return the authorization token."""
    # we use a cookie to authenticate with Google App Engine
    #  by registering a cookie handler here, this will automatically store the
    #  cookie returned when we use urllib2
    cookiejar = cookielib.LWPCookieJar()
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookiejar))
    urllib2.install_opener(opener)

    #
    # get an AuthToken from Google accounts
    #
    auth_uri = 'https://www.google.com/accounts/ClientLogin'
    authreq_data = urllib.urlencode({
        'Email': username,
        'Passwd': pw,
        'service': 'fusiontables',
        'accountType': 'HOSTED_OR_GOOGLE'})
    auth_req = urllib2.Request(auth_uri, data=authreq_data)
    auth_resp = urllib2.urlopen(auth_req)
    auth_resp_body = auth_resp.read()
    # auth response includes several fields - we're interested in
    #  the bit after Auth=
    auth_resp_dict = dict(
        x.split('=') for x in auth_resp_body.split('\n') if x)
    authtoken = auth_resp_dict['Auth']
    return authtoken

def GetAuthToken(users_email_address=None, users_password=None):
    """Tries to log in and returns auth token. Saves token for future use.

    Will prompt for password if not present.
    """
    # Check to see if it's on disk
    if (os.path.exists('.ftclient_authtoken')):
        token = open('.ftclient_authtoken').read().strip()
    else:
        if not users_email_address:
            users_email_address = raw_input('Email address:')
        if not users_password:
            users_password = getpass.getpass(
                'Password for %s: ' % users_email_address)

        token = GoogleClientLogin(users_email_address, users_password)

        fout = open('.ftclient_authtoken', 'w')
        fout.write(token)
        fout.close()

    return token

if __name__ == '__main__':
	pass</pre>
</pre>

  </div>
</div>



  <div class="after_post"><a href="http://kebot.me/2010/10/google-fusion-tables-with-python/#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="sync-your-itunes"></a>
  <h2 class="blog_post_title"><a href="/2010/09/syncyouritunes/" rel="bookmark" title="Permanent Link to Sync Your ITunes">Sync Your ITunes</a></h2>
  <small>September 26, 2010 at 07:45 AM | categories: 

<a href='/category/python'>Python</a>, <a href='/category/project'>Project</a>, <a href='/category/mac'>Mac</a>
 | <a href="http://kebot.me/2010/09/syncyouritunes/#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  
<a href="http://kebot.me/wp-content/uploads/2010/09/icon-grey.jpg"><img class="alignnone size-medium wp-image-5" title="icon-grey" src="http://kebot.me/wp-content/uploads/2010/09/icon-grey-281x300.jpg" alt="" width="281" height="300" /></a>

Project Home:

http://code.google.com/p/syncyouritunes/

  </div>
</div>



  <div class="after_post"><a href="http://kebot.me/2010/09/syncyouritunes/#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />

        </div><!-- End Prose Block -->
      </div><!-- End Main Block -->
      <div id="footer">
        
  <hr/>
  This is a footer that appears on every page.
  <p id="credits">
Powered by <a href="http://www.blogofile.com">Blogofile</a>.<br/>
<br/>
RSS feeds for <a href="/feed">Entries</a>
 and <a
href="http://kebot.disqus.com/latest.rss">Comments</a>.
<br>
</p>
<script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kebot/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>


      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>




